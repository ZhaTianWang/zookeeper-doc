该仓库翻译了zookeeper官方的一些文档,zookeeper版本为3.6.1，原文链接为https://zookeeper.apache.org/doc/r3.6.1/zookeeperAdmin.html

ZooKeeper是一个高性能的，为分布式应用提供协调功能的服务。它用一个简单的接口来暴露通用的服务-例如命名，配置管理，同步和分组服务，因此你不需要从头开始来编写这些服务。无需作重大修改，你就能使用zookeeper来实现一致性，集群管理，leader选举和节点在线协议。并且你可以基于zookeeper实现你自己特殊的需求

**目录**

[概述](#概述)

​	[ZooKeeper:一个分布式的,为分布式应用提供协调功能的服务](#ZooKeeper一个分布式的为分布式应用提供协调功能的服务)

- [设计目标](#设计目标)
- [数据模型和分层的命名空间](#数据模型和分层的命名空间)

[开发者](#开发者)

[管理和运维](#管理和运维)

[投稿](#投稿)

# 概述

## ZooKeeper:一个分布式的,为分布式应用提供协调功能的服务

ZooKeeper是一个分布式的且开源的，为分布式应用提供协调功能的服务。它暴露了一套简单的原语，分布式应用能依赖它来实现更高级的服务，如同步，配置维护，分组和命名。它被设计成易于编程，并且使用了一个熟悉的文件系统的目录树结构的数据模型。它运行在java环境中，且它有java和c的绑定关系。

众所周知，协调服务是非常难以恢复正常的。协调服务特别容易产生诸如竞态条件和死锁的错误。zookeeper的动机就是不再让分布式应用承担从头开始实现协调服务的职责。

### 设计目标

**zookeeper的设计遵循简单的原则**。zookeeper允许分布式的进程通过一个共享的有层次结构的命名空间来互相协调，这个命名空间被组织成一个标准的文件系统。这个命名空间包含在zookeeper术语中被称为znode的数据寄存器，且这些znode与文件和目录类似。不像一个典型的文件系统被设计用作存储，zookeeper的数据被保存在内存中，这意味着zookeeper能够实现高吞吐低延迟。

Zookeeper的实现非常重视高性能，高可用，严格的顺序访问。在zookeeper的性能层面，它能被使用在大型的分布式系统中。在可靠性方面，zookeeper能够避免单点故障。严格的顺序意味着复杂的同步能够在客户端被实现。

**zookeeper基于复制**。与zookeeper协调的分布式进程一样，zookeeper自己通过一组被称之为ensemble的主机来实现复制。

![ZooKeeper Service](https://zookeeper.apache.org/doc/r3.6.1/images/zkservice.jpg)

组成zookeeper服务的每个服务器必须了解其他服务器的状态。这些服务器在内存中维护着其他服务器的状态，除此之外，在一个持久化存储中也维护了一个事物日志和快照。只要大多数服务器是可用的，zookeeper服务就会是可用的。

每个客户端连接到一个zookeeper服务器。客户端维护了一个tcp连接，通过这个连接，客户端发送请求，获取响应，获取监听事件和发送心跳。如果连接服务器的tcp连接中断，这个客户端会连接到另一个不同的服务器。

**zookeeper是有序的**。zookeeper使用了一个数字来记录每一次更新操作，这个数字反映了所有zookeeper事物的顺序。后面的操作能够使用这个顺序来实现更高级的抽象，例如同步。

**zookeeper是快速的**。在以读操作为主的工作任务中，它特别快。zookeeper应用运行在成千上万的机器中，且这些机器的读操作比写操作更多，大约10:1的比例，zookeeper的性能表现最好。

### 数据模型和分层的命名空间

zookeeper提供的命名空间和标准的文件系统非常像。命名空间由一系列被斜线分隔的路径组成。zookeeper的命名空间中的每个节点用一个路径标识。

zookeeper具有层级结构的命名空间

![ZooKeeper's Hierarchical Namespace](/Users/hzh/Desktop/github_markdown_repo/zookeeper-doc/zknamespace.png)

# 开发者

# 管理和运维

# 投稿



